# -*- coding: utf-8 -*-
"""CNN_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k88nBOWeHgOSFVaej604Yr-nMAG_oNp_
"""

from google.colab import drive
drive.mount('/content/drive')

!cp /content/drive/MyDrive/project/utils.py /content/utils.py

pip install python-dotenv

import pandas as pd
import numpy as np
import cv2
from time import perf_counter

import librosa
import librosa.display

import utils

!cp /content/drive/MyDrive/project/raw_tracks.csv /content/raw_tracks.csv
!cp /content/drive/MyDrive/project/mels2.zip /content/mels2.zip
!cp /content/drive/MyDrive/project/files2.txt /content/files2.txt

!cp /content/drive/MyDrive/project/fma_metadata/tracks.csv /content/tracks.csv
!cp /content/drive/MyDrive/project/fma_metadata/genres.csv /content/genres.csv
!cp /content/drive/MyDrive/project/fma_metadata/features.csv /content/features.csv
!cp /content/drive/MyDrive/project/fma_metadata/echonest.csv /content/echonest.csv

!unzip mels2.zip -d .

DOWNSAMPLE_HEIGHT = 128
DOWNSAMPLE_WIDTH = 1291

import ast
f = open("files2.txt", "r")
data = f.read()
indices = ast.literal_eval(data)
f.close()

track_data = pd.read_csv("raw_tracks.csv", index_col = 0)
data = track_data["track_genres"][np.array(indices).astype(int)]
# track_data["track_genres"]

data_dict = dict()
for i in data.keys():
    data_dict[i] = ast.literal_eval(data[i])[0]["genre_title"] #data_dict contains track_ids as keys and genre_ids as values

tracks = utils.load('drive/MyDrive/project/fma_metadata/tracks.csv')

small = tracks['set', 'subset'] <= 'small'

train = tracks['set', 'split'] == 'training'
val = tracks['set', 'split'] == 'validation'
test = tracks['set', 'split'] == 'test'

y_train_initial = tracks.loc[small & train, ('track', 'genre_top')]
y_test_initial = tracks.loc[small & test, ('track', 'genre_top')]
y_val_initial = tracks.loc[small & val, ('track', 'genre_top')]

y_train_initial = y_train_initial.to_frame()
y_test_initial = y_test_initial.to_frame()
y_val_initial = y_val_initial.to_frame()

genres = ('Electronic', 'Experimental', 'Folk', 'Hip-Hop', 'Instrumental', 'International', 'Pop', 'Rock')
genres_dic = dict()
cnt = 0
for i in genres:
  genres_dic[i] = cnt
  cnt += 1

y_train_np = y_train_initial.to_numpy()
y_test_np = y_test_initial.to_numpy()
y_val_np = y_val_initial.to_numpy()
y_train_np[0,0]

x_train = np.zeros((31970, 128, 256))
x_test = np.zeros((4000 , 128, 256))
x_val = np.zeros((4000 , 128, 256))

y_train = np.zeros(31970, dtype = int)
y_test = np.zeros(4000, dtype = int)
y_val = np.zeros(4000, dtype = int)

i1, i2, i3, count = 0, 0, 0, 0
for i in data_dict:
    file = "{:06d}".format(i)
    dir = file[:3]
    track_id = int(file)
    img = cv2.imread(f"/content/mels2/{dir}/{file}.png")
    if img.shape[1] > 1291:
      img = np.delete(img, np.s_[1291:img.shape[1]], axis=1)
    img = cv2.resize(img, (DOWNSAMPLE_WIDTH, DOWNSAMPLE_HEIGHT), interpolation = cv2.INTER_AREA)
    img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) 
    if track_id in y_train_initial.index:
      for j in range(5):
        x_train[5*i1+j] = img[:,256*j:256*(j+1)]
        y_train[5*i1+j] = genres_dic[y_train_np[i1,0]]
      i1 += 1
      count += 1
    elif track_id in y_test_initial.index:
      for j in range(5):
        x_test[5*i2+j] = img[:,256*j:256*(j+1)]
        y_test[5*i2+j] = genres_dic[y_test_np[i2,0]]
      i2 += 1
      count += 1
    elif track_id in y_val_initial.index:
      for j in range(5):
        x_val[5*i3+j] = img[:,256*j:256*(j+1)]
        y_val[5*i3+j] = genres_dic[y_val_np[i3,0]]
      i3 += 1
      count += 1
print(i1,i2,i3,count)

y_train.shape, y_test.shape, y_val.shape

i1, i2, i3

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline
print(y_train[5405])
plt.figure(figsize=(10, 5))
librosa.display.specshow(x_train[5405], y_axis='mel', x_axis='time')
plt.colorbar(format='%+2.0f dB')
plt.title('Test Melspectogram')
plt.tight_layout()

# print(img_datas[3].shape)

# img_datas = normalize(img_datas)
# print(img_datas.shape)

# tracks = utils.load('tracks.csv')
# genres = utils.load('genres.csv')
# features = utils.load('features.csv')
# echonest = utils.load('echonest.csv')

# tracks.shape, genres.shape, features.shape, echonest.shape

"""KNN"""

x_train /= 255
x_test /= 255
x_val /= 255

x_train_cn = np.expand_dims(x_train, axis=3)
x_test_cn = np.expand_dims(x_test, axis=3)
x_val_cn = np.expand_dims(x_val, axis=3)

y_train_cn = np.zeros((y_train.size, y_train.max()+1))
y_train_cn[np.arange(y_train.size),y_train] = 1

y_test_cn = np.zeros((y_test.size, y_test.max()+1))
y_test_cn[np.arange(y_test.size),y_test] = 1

y_val_cn = np.zeros((y_val.size, y_val.max()+1))
y_val_cn[np.arange(y_val.size),y_val] = 1

import tensorflow as tf
from keras import layers
from keras.layers import (Input, Add, Dense, Activation, ZeroPadding2D, BatchNormalization, Flatten, 
                          Conv2D, AveragePooling2D, MaxPooling2D, GlobalMaxPooling2D, Dropout)
from keras.models import Model, load_model
from keras.preprocessing import image
from keras.utils import layer_utils
import pydot
from IPython.display import SVG
from keras.utils.vis_utils import model_to_dot
from keras.initializers import glorot_uniform

from keras.preprocessing.image import ImageDataGenerator
import random

def GenreModel(input_shape = (128,256,1),classes=8):
  
  X_input = Input(input_shape)

  X = Conv2D(8,kernel_size=(8,8),strides=(1,1))(X_input)
  X = BatchNormalization(axis=3)(X)
  X = Activation('relu')(X)
  #X = Dropout(rate=0.3)(X)

  
  X = Conv2D(16,kernel_size=(4,4),strides = (1,1))(X)
  X = BatchNormalization()(X)
  X = Activation('relu')(X)
  #X = Dropout(rate=0.3)(X)
  X = MaxPooling2D((2,2))(X)
  
  X = Conv2D(32,kernel_size=(4,4),strides = (1,1))(X)
  X = BatchNormalization()(X)
  X = Activation('relu')(X)
  #X = Dropout(rate=0.3)(X)

  X = Conv2D(64,kernel_size=(4,4),strides=(1,1))(X)
  X = BatchNormalization()(X)
  X = Activation('relu')(X)
  X = MaxPooling2D((2,2))(X)
  X = Dropout(rate=0.3)(X)

  X = Conv2D(128,kernel_size=(4,4),strides=(1,1))(X)
  X = BatchNormalization()(X)
  X = Activation('relu')(X)
  X = MaxPooling2D((2,2))(X)
  X = Dropout(rate=0.3)(X)
  
  X = Flatten()(X)
  X = Dropout(rate=0.5)(X)
  X = Dense(classes, activation='softmax', name='fc' + str(classes))(X)

  model = Model(inputs=X_input,outputs=X,name='GenreModel')

  return model

model = GenreModel(input_shape=(128,256,1),classes=8)
model.summary()

import keras.backend as K
def get_f1(y_true, y_pred): #taken from old keras source code
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
    precision = true_positives / (predicted_positives + K.epsilon())
    recall = true_positives / (possible_positives + K.epsilon())
    f1_val = 2*(precision*recall)/(precision+recall+K.epsilon())
    return f1_val

opt = tf.keras.optimizers.Adam(learning_rate=0.001)
model.compile(optimizer = opt,loss='categorical_crossentropy',metrics=['accuracy',get_f1]) 

model.fit(x_train_cn, y_train_cn,epochs=70, batch_size = 64, validation_data=(x_test_cn, y_test_cn))